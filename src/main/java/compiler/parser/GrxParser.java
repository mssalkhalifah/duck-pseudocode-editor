package compiler.parser;/* This file was generated by Grammax v1.0.0 */

import compiler.exceptions.semantic.InvalidTypeException;
import compiler.exceptions.semantic.VariableDefinedException;
import compiler.exceptions.semantic.VariableUndefinedException;
import compiler.lexer.Lexer.TokenType;
import compiler.lexer.Lexer.Token;
import compiler.symboltable.SymbolTable;

import java.util.List;
import java.util.Objects;
import java.util.Stack;

public final class GrxParser {
    public static final int T_FLOAT = 0;
    public static final int T_UNARY_INCREMENT = 1;
    public static final int T_ENDINPUT = 2;
    public static final int T_STARTINPUT = 3;
    public static final int T_LT = 4;
    public static final int T_CHAR = 5;
    public static final int T_DO = 6;
    public static final int T_ASSIGN = 7;
    public static final int T_INT = 8;
    public static final int T_CHAR_CONST = 9;
    public static final int T_STR = 10;
    public static final int T_STR_CONST = 11;
    public static final int T_ELSE = 12;
    public static final int T_UNARY_DECREMENT = 13;
    public static final int T_ID = 14;
    public static final int T_IF = 15;
    public static final int T_GE = 16;
    public static final int T_SUB = 17;
    public static final int T_OR = 18;
    public static final int T_MOD = 19;
    public static final int T_MUL = 20;
    public static final int T_NUM_CONST = 21;
    public static final int T_ENIF = 22;
    public static final int T_ENDFOR = 23;
    public static final int T_FOR = 24;
    public static final int T_COLON = 25;
    public static final int T_EQ = 26;
    public static final int T_OPENPA = 27;
    public static final int T_GT = 28;
    public static final int T_OUT = 29;
    public static final int T_SEMICOL = 30;
    public static final int T_DIV = 31;
    public static final int T_NOT = 32;
    public static final int T_BOOL = 33;
    public static final int T_ENDDO = 34;
    public static final int T_AND = 35;
    public static final int T_NE = 36;
    public static final int T_CLOSEPA = 37;
    public static final int T_LE = 38;
    public static final int T_WHILE = 39;
    public static final int T_ENDWHILE = 40;
    public static final int T_BOOL_CONST = 41;
    public static final int T_PLUS = 42;
    public static final int T_EOF = 43;
    private static final int terminalCount = 44;
    private static final int nonTerminalCount = 25;
    private static final List<Integer> actionTable = GrxParserTableFactory.build("Action");
    private static final List<Integer> gotoTable = GrxParserTableFactory.build("Goto");
    private static final int[] productionLabels = {3,6,6,1,9,9,8,8,8,8,8,18,16,16,22,22,13,13,13,21,21,10,4,4,4,4,4,2,2,5,7,7,12,12,24,24,24,11,11,11,11,11,0,0,0,17,17,17,17,14,14,23,15,15,15,19,19,20,20,20,20,20,20};
    @SuppressWarnings("Convert2Lambda")
    private static final Reductor[] reductions = {
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws VariableUndefinedException, VariableDefinedException, InvalidTypeException {
                _grx_stack.pop();
                Token value = (Token) _grx_stack.pop().payload;
                _grx_stack.pop();
                Token type = (Token)_grx_stack.pop().payload;
                _grx_stack.pop();
                Token id = (Token) _grx_stack.pop().payload;
                Object v;
                {
                    SymbolTable.addSymbol(id);
                v = SymbolTable.initAttributes(id, type, value);
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object type = _grx_stack.pop().payload;
                Object v;
                {
                v = type;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object type = _grx_stack.pop().payload;
                Object v;
                {
                v = type;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object type = _grx_stack.pop().payload;
                Object v;
                {
                v = type;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object type = _grx_stack.pop().payload;
                Object v;
                {
                v = type;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object type = _grx_stack.pop().payload;
                Object v;
                {
                v = type;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws VariableUndefinedException, InvalidTypeException {
                Token assignExp = (Token) _grx_stack.pop().payload;
                Token assignOP = (Token) _grx_stack.pop().payload;
                Token unaryExp = (Token) _grx_stack.pop().payload;
                Object v;
                {
                v = SymbolTable.updateAttribute(unaryExp, assignOP, assignExp);
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object andExp = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object orExp = _grx_stack.pop().payload;
                Object v;
                {
                v = null;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object eqExp = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object andExp = _grx_stack.pop().payload;
                Object v;
                {
                v = null;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws InvalidTypeException {
                Object right = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object left = _grx_stack.pop().payload;
                Object v;
                {
                    Token leftToken = (Token) left;
                    Token rightToken = (Token) right;
                  try {
                      float valueLeft = Float.parseFloat((leftToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(leftToken)) : leftToken.getValue());
                      float valueRight = Float.parseFloat((rightToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(rightToken)) : rightToken.getValue());
                    float result = valueLeft + valueRight;
                    v = new Token(TokenType.NUM_CONST, String.valueOf(result), rightToken.getLineNumber(), rightToken.getColumnNumber());
                  } catch(NumberFormatException e) {
                      Token invalidToken = (leftToken.getType() == TokenType.NUM_CONST
                              || leftToken.getType() == TokenType.INT
                              || leftToken.getType() == TokenType.FLOAT) ? rightToken : leftToken;
                    throw new InvalidTypeException(
                            invalidToken.getType().toString(),
                            TokenType.NUM_CONST.toString(), invalidToken.getLineNumber() + 1);
                  }
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws InvalidTypeException {
                Object right = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object left = _grx_stack.pop().payload;
                Object v;
                {
                    Token leftToken = (Token) left;
                    Token rightToken = (Token) right;
                    try {
                        float valueLeft = Float.parseFloat((leftToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(leftToken)) : leftToken.getValue());
                        float valueRight = Float.parseFloat((rightToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(rightToken)) : rightToken.getValue());
                        float result = valueLeft - valueRight;
                        v = new Token(TokenType.NUM_CONST, String.valueOf(result), rightToken.getLineNumber(), rightToken.getColumnNumber());
                    } catch(NumberFormatException e) {
                        Token invalidToken = (leftToken.getType() == TokenType.NUM_CONST
                                || leftToken.getType() == TokenType.INT
                                || leftToken.getType() == TokenType.FLOAT) ? rightToken : leftToken;
                        throw new InvalidTypeException(
                                invalidToken.getType().toString(),
                                TokenType.NUM_CONST.toString(), invalidToken.getLineNumber() + 1);
                    }
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws InvalidTypeException {
                Object right = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object left = _grx_stack.pop().payload;
                Object v;
                {
                    Token leftToken = (Token) left;
                    Token rightToken = (Token) right;
                    try {
                        float valueLeft = Float.parseFloat((leftToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(leftToken)) : leftToken.getValue());
                        float valueRight = Float.parseFloat((rightToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(rightToken)) : rightToken.getValue());
                        float result = valueLeft * valueRight;
                        v = new Token(TokenType.NUM_CONST, String.valueOf(result), rightToken.getLineNumber(), rightToken.getColumnNumber());
                    } catch(NumberFormatException e) {
                        Token invalidToken = (leftToken.getType() == TokenType.NUM_CONST
                                || leftToken.getType() == TokenType.INT
                                || leftToken.getType() == TokenType.FLOAT) ? rightToken : leftToken;
                        throw new InvalidTypeException(
                                invalidToken.getType().toString(),
                                TokenType.NUM_CONST.toString(), invalidToken.getLineNumber() + 1);
                    }
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws InvalidTypeException {
                Object right = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object left = _grx_stack.pop().payload;
                Object v;
                {
                    Token leftToken = (Token) left;
                    Token rightToken = (Token) right;
                    try {
                        float valueLeft = Float.parseFloat((leftToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(leftToken)) : leftToken.getValue());
                        float valueRight = Float.parseFloat((rightToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(rightToken)) : rightToken.getValue());
                        float result = valueLeft / valueRight;
                        v = new Token(TokenType.NUM_CONST, String.valueOf(result), rightToken.getLineNumber(), rightToken.getColumnNumber());
                    } catch(NumberFormatException e) {
                        Token invalidToken = (leftToken.getType() == TokenType.NUM_CONST
                                || leftToken.getType() == TokenType.INT
                                || leftToken.getType() == TokenType.FLOAT) ? rightToken : leftToken;
                        throw new InvalidTypeException(
                                invalidToken.getType().toString(),
                                TokenType.NUM_CONST.toString(), invalidToken.getLineNumber() + 1);
                    }
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) throws InvalidTypeException {
                Object right = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object left = _grx_stack.pop().payload;
                Object v;
                {
                    Token leftToken = (Token) left;
                    Token rightToken = (Token) right;
                    try {
                        float valueLeft = Float.parseFloat((leftToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(leftToken)) : leftToken.getValue());
                        float valueRight = Float.parseFloat((rightToken.getType() == TokenType.ID) ? String.valueOf(SymbolTable.getValue(rightToken)) : rightToken.getValue());
                        float result = valueLeft % valueRight;
                        v = new Token(TokenType.NUM_CONST, String.valueOf(result), rightToken.getLineNumber(), rightToken.getColumnNumber());
                    } catch(NumberFormatException e) {
                        Token invalidToken = (leftToken.getType() == TokenType.NUM_CONST
                                || leftToken.getType() == TokenType.INT
                                || leftToken.getType() == TokenType.FLOAT) ? rightToken : leftToken;
                        throw new InvalidTypeException(
                                invalidToken.getType().toString(),
                                TokenType.NUM_CONST.toString(), invalidToken.getLineNumber() + 1);
                    }
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object exp = _grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object assign = _grx_stack.pop().payload;
                Object v;
                {
                v = assign;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object not = _grx_stack.pop().payload;
                Object v;
                {
                v = not;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object increment = _grx_stack.pop().payload;
                Object v;
                {
                v = increment;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object decrement = _grx_stack.pop().payload;
                Object v;
                {
                v = decrement;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Token exp = (Token)_grx_stack.pop().payload;
                Object v;
                {
                v = exp;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                _grx_stack.pop();
                return null;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object id = _grx_stack.pop().payload;
                Object v;
                {
                v = id;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object number = _grx_stack.pop().payload;
                Object v;
                {
                v = number;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object string = _grx_stack.pop().payload;
                Object v;
                {
                v = string;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object charType = _grx_stack.pop().payload;
                Object v;
                {
                v = charType;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                Object bool = _grx_stack.pop().payload;
                Object v;
                {
                v = bool;
                }
                return v;
            }
        },
        new Reductor() {
            @Override
            public Object reduce(Stack<StackEntry> _grx_stack) {
                _grx_stack.pop();
                Object exp = _grx_stack.pop().payload;
                _grx_stack.pop();
                Object v;
                {
                v = exp;
                }
                return v;
            }
        }
    };
    private static final StackEntry initialStackEntry = new StackEntry(0, null);
    private Stack<StackEntry> stack;
    private Object payload = null;
    private static final class StackEntry {
        private final int previousState;
        private final Object payload;
        private StackEntry(int previousState, Object payload) {
            this.previousState = previousState;
            this.payload = payload;
        }
    }
    private interface Reductor {
        Object reduce(Stack<StackEntry> _grx_stack) throws VariableUndefinedException, VariableDefinedException, InvalidTypeException;
    }
    public GrxParser() {
        stack = new Stack<>();
        stack.push(initialStackEntry);
    }
    public void reset() {
        stack.clear();
        stack.push(initialStackEntry);
        payload = null;
    }
    public void parse(int tokenId, Object tokenPayload) throws VariableUndefinedException, VariableDefinedException, InvalidTypeException {
        while (true) {
            int action = Objects.requireNonNull(actionTable).get(terminalCount * stack.peek().previousState + tokenId);
            if (action == 0) {
                throw new RuntimeException("Syntax error");
            }
            if (action == -1) {
                payload = stack.peek().payload;
                return;
            }
            if (action > 0) {
                stack.push(new StackEntry(action - 1, tokenPayload));
                return;
            }
            int productionIndex = -action - 2;
            Object reducedProduction = reductions[productionIndex].reduce(stack);
            StackEntry newState = stack.peek();
            int nextState = Objects.requireNonNull(gotoTable).get(newState.previousState * nonTerminalCount + productionLabels[productionIndex]);
            stack.push(new StackEntry(nextState - 1, reducedProduction));
        }
    }
    public boolean successfullyParsed() {
        return payload != null;
    }
    public Object getValue() {
        assert payload != null : "parsing did not succeed";
        return payload;
    }
}